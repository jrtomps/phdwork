// SubtractBgnd.cpp
//
// Jeromy Tompkins
// 8/9/2011
//
// Simple subtracts the histograms found in the fbg file from 
// the fprod file. The macro assumes that these are already normalized
// to the 5Pad.

#include <cstdlib>
#include <iomanip>
#include <iostream>
#include <string>
#include <algorithm>
#include "include/ConfigManager.h"
#include "include/ConfigEntry.h"
#include "include/FNameManager.h"
#include "include/PAnalysis.h"
#include "TH1.h"
#include "TFile.h"
#include "TKey.h"
#include "TList.h"
#include "TMath.h"

using namespace std;
using namespace PAnalysis;

FNameManager  fnm("/home/jrtomps/pffrag1/analysis/fnameconfig.dat");
ConfigManager acm;

vector<TH1F*>
GetAllTH1F(TFile& rootfile)
{
  TH1F *h=0;
  TKey *obj=0;
  TListIter li(rootfile.GetListOfKeys());
  vector<TH1F*> histvec;

  while (obj = static_cast<TKey*>(li.Next()))
    {
      h = dynamic_cast<TH1F*>(obj->ReadObj());
      if (h!=NULL)
        {
          string s(h->GetName());
	  size_t i1 = s.find("adc");
	  size_t i2 = s.find("shifted_norm_vclk");
          if (    i1 < 20 && i1>=0
	       && i2 < 20 && i2>=0 )
	    histvec.push_back(h);
        }
    }
  cout << histvec.size() << endl;
  return histvec;
}

Bool_t
IsNotADC(TH1F* h)
{  return  (string(h->GetName()).find("adc") == string::npos); }

void
FilterOutTDC(vector<TH1F*>& vec)
{
  vector<TH1F*>::iterator iend = remove_if(vec.begin(), vec.end(), IsNotADC);
  vec.resize(iend-vec.begin());
  cout << "Filtered size = " << vec.size() << endl;
}

void
Reset(TH1F* h)
{
  for (Int_t i=0; i<h->GetNbinsX(); i++)
    {
      h->SetBinContent(i,0);
      h->SetBinError(i,0);
    }
}

void
InspectSingleHistErrors(TH1F* h)
{
  cout << h->GetName() << endl;
  Double_t x, ex;
  for (Int_t i=0; i<h->GetNbinsX(); i++)
    {
      x  = h->GetBinContent(i);
      ex = h->GetBinError(i);
      if (x!=0 && ex/x > 1.0001) 
	cout << "bin:" << i << "\tcontent:" << x << "\terr:" << ex 
	     << " \terr/content:" << ex/x << endl;
    }
}

TH1F*
GenerateConsistentHist(TH1F* hbg, TH1F* hprod)
{
  TH1F* hpprod = 0;
  if (hbg!=NULL && hprod!=NULL) 
    {
      hpprod = dynamic_cast<TH1F*>(hbg->Clone(hprod->GetName()));
      if (hpprod!=NULL)
	{
	  Reset(hpprod);
	  Double_t binctr=0, x=0, ex=0;
	  cout << hpprod->GetName() << endl;
	  for(Int_t i=1; i<=hpprod->GetNbinsX(); i++)
	    {
	      binctr = hbg->GetBinCenter(i);
	      x  = hprod->GetBinContent(hprod->GetXaxis()->FindBin(binctr));
	      ex = hprod->GetBinError(hprod->GetXaxis()->FindBin(binctr));
	      if (x!=0 && ex/x > 1.0001) 
		cout << "bin:" << i << "\tcontent:" << x << "\terr:" << ex 
		     << " \terr/content:" << ex/x << endl;
	      hpprod->SetBinContent(i,x);
	      hpprod->SetBinError(i,ex);
	    }
	  
	}
    }
  return hpprod;
}
  
void
EnforceAxisRangeConsistency(vector<TH1F*>& hbg, vector<TH1F*>& hprod)
{
  vector<TH1F*> hres(hprod.size(),NULL);
  transform(hbg.begin(),hbg.end(),hprod.begin(), hres.begin(), GenerateConsistentHist);
  copy(hres.begin(), hres.end(), hprod.begin());
}

void
CalcErrors(TH1F* hcl, TH1F* hbg, TH1F* h)
{
  using TMath::Power;
  using TMath::Sqrt;

  Double_t exbg, ex;
  for (Int_t i=0; i<=hcl->GetNbinsX()+1; i++)
    {
      exbg = hbg->GetBinError(i);
      ex   = h->GetBinError(i);
 
      hcl->SetBinError(i,Sqrt(Power(exbg,2.0)+Power(ex,2.0)));
    }
}

void
SubtractBgndRuns(TFile *fbg, TFile *fprod, const Char_t *foutname)
{
  vector<TH1F*> histbg   = GetAllTH1F(*fbg);
  FilterOutTDC(histbg);
  vector<TH1F*> histprod = GetAllTH1F(*fprod);
  //  for_each(histprod.begin(), histprod.end(), InspectSingleHistErrors); 
  FilterOutTDC(histprod);   

  EnforceAxisRangeConsistency(histbg, histprod);

  string foname = foutname;
  TFile fout(foname.data(),"UPDATE");

  TH1F *hbg=0, *h=0, *h_cl=0;
  for (UInt_t i=0; i<min(histbg.size(), histprod.size()); i++)
    {
      hbg = histbg.at(i);
      h   = histprod.at(i);

      cout << histbg.at(i)->GetName() << " subbed from " << histprod.at(i)->GetName() << endl;

      h_cl = static_cast<TH1F*>(h->Clone(Form("normed_bgsubbed_adc%i",i)));
      h_cl->SetTitle(Form("Overnight Bgnd Subtracted ADC%i",i));
      h_cl->Add(hbg,-1.0);
      // The next line is only valid if Sumw2 is not turned on
      //  CalcErrors(h_cl, hbg, h);
    
      fout.cd();
      h_cl->Write("",TObject::kOverwrite);
    }
    
  fout.Close();
  
}

